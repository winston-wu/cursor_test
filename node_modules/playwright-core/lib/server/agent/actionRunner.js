"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var actionRunner_exports = {};
__export(actionRunner_exports, {
  runAction: () => runAction,
  serializeArgument: () => serializeArgument
});
module.exports = __toCommonJS(actionRunner_exports);
var import_expectUtils = require("../utils/expectUtils");
var import_serializers = require("../../protocol/serializers");
async function runAction(progress, page, action, secrets) {
  const frame = page.mainFrame();
  switch (action.method) {
    case "click":
      await frame.click(progress, action.selector, { ...action.options, ...strictTrue });
      break;
    case "drag":
      await frame.dragAndDrop(progress, action.sourceSelector, action.targetSelector, { ...strictTrue });
      break;
    case "hover":
      await frame.hover(progress, action.selector, { ...action.options, ...strictTrue });
      break;
    case "selectOption":
      await frame.selectOption(progress, action.selector, [], action.labels.map((a) => ({ label: a })), { ...strictTrue });
      break;
    case "pressKey":
      await page.keyboard.press(progress, action.key);
      break;
    case "pressSequentially": {
      const secret = secrets?.find((s) => s.name === action.text)?.value ?? action.text;
      await frame.type(progress, action.selector, secret, { ...strictTrue });
      if (action.submit)
        await page.keyboard.press(progress, "Enter");
      break;
    }
    case "fill": {
      const secret = secrets?.find((s) => s.name === action.text)?.value ?? action.text;
      await frame.fill(progress, action.selector, secret, { ...strictTrue });
      if (action.submit)
        await page.keyboard.press(progress, "Enter");
      break;
    }
    case "setChecked":
      if (action.checked)
        await frame.check(progress, action.selector, { ...strictTrue });
      else
        await frame.uncheck(progress, action.selector, { ...strictTrue });
      break;
    case "expectVisible": {
      const result = await frame.expect(progress, action.selector, { expression: "to.be.visible", isNot: false }, 5e3);
      if (result.errorMessage)
        throw new Error(result.errorMessage);
      break;
    }
    case "expectValue": {
      let result;
      if (action.type === "textbox" || action.type === "combobox" || action.type === "slider") {
        const expectedText = (0, import_expectUtils.serializeExpectedTextValues)([action.value]);
        result = await frame.expect(progress, action.selector, { expression: "to.have.value", expectedText, isNot: false }, 5e3);
      } else if (action.type === "checkbox" || action.type === "radio") {
        const expectedValue = serializeArgument({ checked: true });
        result = await frame.expect(progress, action.selector, { expression: "to.be.checked", expectedValue, isNot: false }, 5e3);
      } else {
        throw new Error(`Unsupported element type: ${action.type}`);
      }
      if (result.errorMessage)
        throw new Error(result.errorMessage);
      break;
    }
  }
}
function serializeArgument(arg) {
  return {
    value: (0, import_serializers.serializePlainValue)(arg),
    handles: []
  };
}
const strictTrue = { strict: true };
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  runAction,
  serializeArgument
});
