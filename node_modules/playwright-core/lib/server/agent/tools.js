"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var tools_exports = {};
__export(tools_exports, {
  default: () => tools_default
});
module.exports = __toCommonJS(tools_exports);
var import_mcpBundle = require("../../mcpBundle");
var import_locatorUtils = require("../../utils/isomorphic/locatorUtils");
function defineTool(tool) {
  return tool;
}
const baseSchema = import_mcpBundle.z.object({
  thatShouldBeIt: import_mcpBundle.z.boolean().describe("Indicates that this tool call is sufficient to complete the task. If false, the task will continue with the next tool call")
});
const snapshot = defineTool({
  schema: {
    name: "browser_snapshot",
    title: "Page snapshot",
    description: "Capture accessibility snapshot of the current page, this is better than screenshot",
    inputSchema: baseSchema
  },
  handle: async (context, params) => {
    return await context.snapshotResult();
  }
});
const elementSchema = baseSchema.extend({
  element: import_mcpBundle.z.string().describe("Human-readable element description used to obtain permission to interact with the element"),
  ref: import_mcpBundle.z.string().describe("Exact target element reference from the page snapshot")
});
const clickSchema = elementSchema.extend({
  doubleClick: import_mcpBundle.z.boolean().optional().describe("Whether to perform a double click instead of a single click"),
  button: import_mcpBundle.z.enum(["left", "right", "middle"]).optional().describe("Button to click, defaults to left"),
  modifiers: import_mcpBundle.z.array(import_mcpBundle.z.enum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"])).optional().describe("Modifier keys to press")
});
const click = defineTool({
  schema: {
    name: "browser_click",
    title: "Click",
    description: "Perform click on a web page",
    inputSchema: clickSchema
  },
  handle: async (context, params) => {
    const [selector] = await context.refSelectors([params]);
    return await context.runActionAndWait({
      method: "click",
      selector,
      options: {
        button: params.button,
        modifiers: params.modifiers,
        clickCount: params.doubleClick ? 2 : void 0
      }
    });
  }
});
const drag = defineTool({
  schema: {
    name: "browser_drag",
    title: "Drag mouse",
    description: "Perform drag and drop between two elements",
    inputSchema: baseSchema.extend({
      startElement: import_mcpBundle.z.string().describe("Human-readable source element description used to obtain the permission to interact with the element"),
      startRef: import_mcpBundle.z.string().describe("Exact source element reference from the page snapshot"),
      endElement: import_mcpBundle.z.string().describe("Human-readable target element description used to obtain the permission to interact with the element"),
      endRef: import_mcpBundle.z.string().describe("Exact target element reference from the page snapshot")
    })
  },
  handle: async (context, params) => {
    const [sourceSelector, targetSelector] = await context.refSelectors([
      { ref: params.startRef, element: params.startElement },
      { ref: params.endRef, element: params.endElement }
    ]);
    return await context.runActionAndWait({
      method: "drag",
      sourceSelector,
      targetSelector
    });
  }
});
const hoverSchema = elementSchema.extend({
  modifiers: import_mcpBundle.z.array(import_mcpBundle.z.enum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"])).optional().describe("Modifier keys to press")
});
const hover = defineTool({
  schema: {
    name: "browser_hover",
    title: "Hover mouse",
    description: "Hover over element on page",
    inputSchema: hoverSchema
  },
  handle: async (context, params) => {
    const [selector] = await context.refSelectors([params]);
    return await context.runActionAndWait({
      method: "hover",
      selector,
      options: {
        modifiers: params.modifiers
      }
    });
  }
});
const selectOptionSchema = elementSchema.extend({
  values: import_mcpBundle.z.array(import_mcpBundle.z.string()).describe("Array of values to select in the dropdown. This can be a single value or multiple values.")
});
const selectOption = defineTool({
  schema: {
    name: "browser_select_option",
    title: "Select option",
    description: "Select an option in a dropdown",
    inputSchema: selectOptionSchema
  },
  handle: async (context, params) => {
    const [selector] = await context.refSelectors([params]);
    return await context.runActionAndWait({
      method: "selectOption",
      selector,
      labels: params.values
    });
  }
});
const pressKey = defineTool({
  schema: {
    name: "browser_press_key",
    title: "Press a key",
    description: "Press a key on the keyboard",
    inputSchema: import_mcpBundle.z.object({
      key: import_mcpBundle.z.string().describe("Name of the key to press or a character to generate, such as `ArrowLeft` or `a`")
    })
  },
  handle: async (context, params) => {
    return await context.runActionAndWait({
      method: "pressKey",
      key: params.key
    });
  }
});
const typeSchema = elementSchema.extend({
  text: import_mcpBundle.z.string().describe("Text to type into the element"),
  submit: import_mcpBundle.z.boolean().optional().describe("Whether to submit entered text (press Enter after)"),
  slowly: import_mcpBundle.z.boolean().optional().describe("Whether to type one character at a time. Useful for triggering key handlers in the page. By default entire text is filled in at once.")
});
const type = defineTool({
  schema: {
    name: "browser_type",
    title: "Type text",
    description: "Type text into editable element",
    inputSchema: typeSchema
  },
  handle: async (context, params) => {
    const [selector] = await context.refSelectors([params]);
    if (params.slowly) {
      return await context.runActionAndWait({
        method: "pressSequentially",
        selector,
        text: params.text,
        submit: params.submit
      });
    } else {
      return await context.runActionAndWait({
        method: "fill",
        selector,
        text: params.text,
        submit: params.submit
      });
    }
  }
});
const fillForm = defineTool({
  schema: {
    name: "browser_fill_form",
    title: "Fill form",
    description: "Fill multiple form fields",
    inputSchema: baseSchema.extend({
      fields: import_mcpBundle.z.array(import_mcpBundle.z.object({
        name: import_mcpBundle.z.string().describe("Human-readable field name"),
        type: import_mcpBundle.z.enum(["textbox", "checkbox", "radio", "combobox", "slider"]).describe("Type of the field"),
        ref: import_mcpBundle.z.string().describe("Exact target field reference from the page snapshot"),
        value: import_mcpBundle.z.string().describe("Value to fill in the field. If the field is a checkbox, the value should be `true` or `false`. If the field is a combobox, the value should be the text of the option.")
      })).describe("Fields to fill in")
    })
  },
  handle: async (context, params) => {
    const actions = [];
    for (const field of params.fields) {
      const [selector] = await context.refSelectors([{ ref: field.ref, element: field.name }]);
      if (field.type === "textbox" || field.type === "slider") {
        actions.push({
          method: "fill",
          selector,
          text: field.value
        });
      } else if (field.type === "checkbox" || field.type === "radio") {
        actions.push({
          method: "setChecked",
          selector,
          checked: field.value === "true"
        });
      } else if (field.type === "combobox") {
        actions.push({
          method: "selectOption",
          selector,
          labels: [field.value]
        });
      }
    }
    return await context.runActionsAndWait(actions);
  }
});
const expectVisible = defineTool({
  schema: {
    name: "browser_expect_visible",
    title: "Expect element visible",
    description: "Expect element is visible on the page",
    inputSchema: baseSchema.extend({
      role: import_mcpBundle.z.string().describe('ROLE of the element. Can be found in the snapshot like this: `- {ROLE} "Accessible Name":`'),
      accessibleName: import_mcpBundle.z.string().describe('ACCESSIBLE_NAME of the element. Can be found in the snapshot like this: `- role "{ACCESSIBLE_NAME}"`')
    })
  },
  handle: async (context, params) => {
    return await context.runActionAndWait({
      method: "expectVisible",
      selector: (0, import_locatorUtils.getByRoleSelector)(params.role, { name: params.accessibleName })
    });
  }
});
const expectVisibleText = defineTool({
  schema: {
    name: "browser_expect_visible_text",
    title: "Expect text visible",
    description: `Expect text is visible on the page. Prefer ${expectVisible.schema.name} if possible.`,
    inputSchema: baseSchema.extend({
      text: import_mcpBundle.z.string().describe('TEXT to expect. Can be found in the snapshot like this: `- role "Accessible Name": {TEXT}` or like this: `- text: {TEXT}`')
    })
  },
  handle: async (context, params) => {
    return await context.runActionAndWait({
      method: "expectVisible",
      selector: (0, import_locatorUtils.getByTextSelector)(params.text)
    });
  }
});
const expectValue = defineTool({
  schema: {
    name: "browser_expect_value",
    title: "Expect value",
    description: "Expect element value",
    inputSchema: baseSchema.extend({
      type: import_mcpBundle.z.enum(["textbox", "checkbox", "radio", "combobox", "slider"]).describe("Type of the element"),
      element: import_mcpBundle.z.string().describe("Human-readable element description"),
      ref: import_mcpBundle.z.string().describe("Exact target element reference from the page snapshot"),
      value: import_mcpBundle.z.string().describe('Value to expect. For checkbox, use "true" or "false".')
    })
  },
  handle: async (context, params) => {
    const [selector] = await context.refSelectors([{ ref: params.ref, element: params.element }]);
    return await context.runActionAndWait({
      method: "expectValue",
      selector,
      type: params.type,
      value: params.value
    });
  }
});
var tools_default = [
  snapshot,
  click,
  drag,
  hover,
  selectOption,
  pressKey,
  type,
  fillForm,
  expectVisible,
  expectVisibleText,
  expectValue
];
