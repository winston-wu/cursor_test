"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var response_exports = {};
__export(response_exports, {
  RenderedResponse: () => RenderedResponse,
  Response: () => Response,
  parseResponse: () => parseResponse,
  requestDebug: () => requestDebug
});
module.exports = __toCommonJS(response_exports);
var import_utilsBundle = require("playwright-core/lib/utilsBundle");
var import_tab = require("./tab");
const requestDebug = (0, import_utilsBundle.debug)("pw:mcp:request");
class Response {
  constructor(context, toolName, toolArgs) {
    this._result = [];
    this._code = [];
    this._images = [];
    this._files = [];
    this._includeSnapshot = "none";
    this._includeTabs = false;
    this._includeMetaOnly = false;
    this._context = context;
    this.toolName = toolName;
    this.toolArgs = toolArgs;
  }
  addResult(result) {
    this._result.push(result);
  }
  addError(error) {
    this._result.push(error);
    this._isError = true;
  }
  isError() {
    return this._isError;
  }
  result() {
    return this._result.join("\n");
  }
  addCode(code) {
    this._code.push(code);
  }
  code() {
    return this._code.join("\n");
  }
  addImage(image) {
    this._images.push(image);
  }
  images() {
    return this._images;
  }
  async addFile(fileName, options) {
    const resolvedFile = await this._context.outputFile(fileName, options);
    this._files.push({ fileName: resolvedFile, title: options.reason });
    return resolvedFile;
  }
  setIncludeSnapshot() {
    this._includeSnapshot = this._context.config.snapshot.mode;
  }
  setIncludeFullSnapshot() {
    this._includeSnapshot = "full";
  }
  setIncludeTabs() {
    this._includeTabs = true;
  }
  setIncludeModalStates(modalStates) {
    this._includeModalStates = modalStates;
  }
  setIncludeMetaOnly() {
    this._includeMetaOnly = true;
  }
  async finish() {
    if (this._includeSnapshot !== "none" && this._context.currentTab())
      this._tabSnapshot = await this._context.currentTabOrDie().captureSnapshot();
    for (const tab of this._context.tabs())
      await tab.updateTitle();
  }
  tabSnapshot() {
    return this._tabSnapshot;
  }
  logBegin() {
    if (requestDebug.enabled)
      requestDebug(this.toolName, this.toolArgs);
  }
  logEnd() {
    if (requestDebug.enabled)
      requestDebug(this.serialize());
  }
  render() {
    const renderedResponse = new RenderedResponse();
    if (this._result.length)
      renderedResponse.results.push(...this._result);
    if (this._code.length)
      renderedResponse.code.push(...this._code);
    if (this._includeSnapshot !== "none" || this._includeTabs) {
      const tabsMarkdown = renderTabsMarkdown(this._context.tabs(), this._includeTabs);
      if (tabsMarkdown.length)
        renderedResponse.states.tabs = tabsMarkdown.join("\n");
    }
    if (this._tabSnapshot?.modalStates.length) {
      const modalStatesMarkdown = (0, import_tab.renderModalStates)(this._tabSnapshot.modalStates);
      renderedResponse.states.modal = modalStatesMarkdown.join("\n");
    } else if (this._tabSnapshot) {
      renderTabSnapshot(this._tabSnapshot, this._includeSnapshot, renderedResponse);
    } else if (this._includeModalStates) {
      const modalStatesMarkdown = (0, import_tab.renderModalStates)(this._includeModalStates);
      renderedResponse.states.modal = modalStatesMarkdown.join("\n");
    }
    if (this._files.length) {
      const lines = [];
      for (const file of this._files)
        lines.push(`- [${file.title}](${file.fileName})`);
      renderedResponse.updates.push({ category: "files", content: lines.join("\n") });
    }
    return this._context.config.secrets ? renderedResponse.redact(this._context.config.secrets) : renderedResponse;
  }
  serialize(options = {}) {
    const renderedResponse = this.render();
    const includeMeta = options._meta && "dev.lowire/history" in options._meta && "dev.lowire/state" in options._meta;
    const _meta = includeMeta ? renderedResponse.asMeta() : void 0;
    const content = [
      {
        type: "text",
        text: renderedResponse.asText(this._includeMetaOnly ? { categories: ["files"] } : void 0)
      }
    ];
    if (this._includeMetaOnly)
      return { _meta, content, isError: this._isError };
    if (this._context.config.imageResponses !== "omit") {
      for (const image of this._images)
        content.push({ type: "image", data: image.data.toString("base64"), mimeType: image.contentType });
    }
    return {
      _meta,
      content,
      isError: this._isError
    };
  }
}
function renderTabSnapshot(tabSnapshot, includeSnapshot, response) {
  if (tabSnapshot.consoleMessages.length) {
    const lines2 = [];
    for (const message of tabSnapshot.consoleMessages)
      lines2.push(`- ${trim(message.toString(), 100)}`);
    response.updates.push({ category: "console", content: lines2.join("\n") });
  }
  if (tabSnapshot.downloads.length) {
    const lines2 = [];
    for (const entry of tabSnapshot.downloads) {
      if (entry.finished)
        lines2.push(`- Downloaded file ${entry.download.suggestedFilename()} to ${entry.outputFile}`);
      else
        lines2.push(`- Downloading file ${entry.download.suggestedFilename()} ...`);
    }
    response.updates.push({ category: "downloads", content: lines2.join("\n") });
  }
  if (includeSnapshot === "incremental" && tabSnapshot.ariaSnapshotDiff === "") {
    return;
  }
  const lines = [];
  lines.push(`- Page URL: ${tabSnapshot.url}`);
  lines.push(`- Page Title: ${tabSnapshot.title}`);
  if (includeSnapshot !== "none") {
    lines.push(`- Page Snapshot:`);
    lines.push("```yaml");
    if (includeSnapshot === "incremental" && tabSnapshot.ariaSnapshotDiff !== void 0)
      lines.push(tabSnapshot.ariaSnapshotDiff);
    else
      lines.push(tabSnapshot.ariaSnapshot);
    lines.push("```");
  }
  response.states.page = lines.join("\n");
}
function renderTabsMarkdown(tabs, force = false) {
  if (tabs.length === 1 && !force)
    return [];
  if (!tabs.length)
    return ['No open tabs. Use the "browser_navigate" tool to navigate to a page first.'];
  const lines = [];
  for (let i = 0; i < tabs.length; i++) {
    const tab = tabs[i];
    const current = tab.isCurrentTab() ? " (current)" : "";
    lines.push(`- ${i}:${current} [${tab.lastTitle()}] (${tab.page.url()})`);
  }
  return lines;
}
function trim(text, maxLength) {
  if (text.length <= maxLength)
    return text;
  return text.slice(0, maxLength) + "...";
}
class RenderedResponse {
  constructor(copy) {
    this.states = {};
    this.updates = [];
    this.results = [];
    this.code = [];
    if (copy) {
      this.states = copy.states;
      this.updates = copy.updates;
      this.results = copy.results;
      this.code = copy.code;
    }
  }
  asText(filter) {
    const text = [];
    if (this.results.length)
      text.push(`### Result
${this.results.join("\n")}
`);
    if (this.code.length)
      text.push(`### Ran Playwright code
${this.code.join("\n")}
`);
    for (const { category, content } of this.updates) {
      if (filter && !filter.categories.includes(category))
        continue;
      if (!content.trim())
        continue;
      switch (category) {
        case "console":
          text.push(`### New console messages
${content}
`);
          break;
        case "downloads":
          text.push(`### Downloads
${content}
`);
          break;
        case "files":
          text.push(`### Files
${content}
`);
          break;
      }
    }
    for (const [category, value] of Object.entries(this.states)) {
      if (filter && !filter.categories.includes(category))
        continue;
      if (!value.trim())
        continue;
      switch (category) {
        case "page":
          text.push(`### Page state
${value}
`);
          break;
        case "tabs":
          text.push(`### Open tabs
${value}
`);
          break;
        case "modal":
          text.push(`### Modal state
${value}
`);
          break;
      }
    }
    return text.join("\n");
  }
  asMeta() {
    const codeUpdate = this.code.length ? { category: "code", content: this.code.join("\n") } : void 0;
    const resultUpdate = this.results.length ? { category: "result", content: this.results.join("\n") } : void 0;
    const updates = [resultUpdate, codeUpdate, ...this.updates].filter(Boolean);
    return {
      "dev.lowire/history": updates,
      "dev.lowire/state": { ...this.states }
    };
  }
  redact(secrets) {
    const redactText = (text) => {
      for (const [secretName, secretValue] of Object.entries(secrets))
        text = text.replaceAll(secretValue, `<secret>${secretName}</secret>`);
      return text;
    };
    const updates = this.updates.map((update) => ({ ...update, content: redactText(update.content) }));
    const results = this.results.map((result) => redactText(result));
    const code = this.code.map((code2) => redactText(code2));
    const states = Object.fromEntries(Object.entries(this.states).map(([key, value]) => [key, redactText(value)]));
    return new RenderedResponse({ states, updates, results, code });
  }
}
function parseSections(text) {
  const sections = /* @__PURE__ */ new Map();
  const sectionHeaders = text.split(/^### /m).slice(1);
  for (const section of sectionHeaders) {
    const firstNewlineIndex = section.indexOf("\n");
    if (firstNewlineIndex === -1)
      continue;
    const sectionName = section.substring(0, firstNewlineIndex);
    const sectionContent = section.substring(firstNewlineIndex + 1).trim();
    sections.set(sectionName, sectionContent);
  }
  return sections;
}
function parseResponse(response) {
  if (response.content?.[0].type !== "text")
    return void 0;
  const text = response.content[0].text;
  const sections = parseSections(text);
  const result = sections.get("Result");
  const code = sections.get("Ran Playwright code");
  const tabs = sections.get("Open tabs");
  const pageState = sections.get("Page state");
  const consoleMessages = sections.get("New console messages");
  const modalState = sections.get("Modal state");
  const downloads = sections.get("Downloads");
  const files = sections.get("Files");
  const codeNoFrame = code?.replace(/^```js\n/, "").replace(/\n```$/, "");
  const isError = response.isError;
  const attachments = response.content.slice(1);
  return {
    result,
    code: codeNoFrame,
    tabs,
    pageState,
    consoleMessages,
    modalState,
    downloads,
    files,
    isError,
    attachments,
    _meta: response._meta
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RenderedResponse,
  Response,
  parseResponse,
  requestDebug
});
